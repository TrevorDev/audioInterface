{
  "name": "alsa",
  "description": "ALSA bindings for Node.js",
  "keywords": [
    "audio",
    "sound",
    "alsa",
    "libasound"
  ],
  "version": "0.0.1",
  "author": {
    "name": "Greg Thornton",
    "email": "xdissent@me.com",
    "url": "http://xdissent.com"
  },
  "license": "MIT",
  "homepage": "https://github.com/xdissent/node-alsa",
  "main": "./lib/index.js",
  "repository": {
    "type": "git",
    "url": "https://github.com/xdissent/node-alsa.git"
  },
  "bugs": {
    "url": "https://github.com/xdissent/node-alsa/issues"
  },
  "dependencies": {
    "ffi": "~1.2.5",
    "ref": "~0.1.3"
  },
  "devDependencies": {
    "coffee-script": ">= 1.6.2"
  },
  "scripts": {
    "prepublish": "coffee -cbo lib src"
  },
  "readme": "node-alsa\n=========\n\nALSA bindings for Node.js\n\n\nRequirements\n------------\n\nYou must have a system on which ALSA is supported with the `libasound2-dev` package installed:\n\n```sh\n$ sudo apt-get install libasound2-dev\n```\n\nYou'll also probably want to have an audio device for either playback or capture.\n\n\nInstallation\n------------\n\nInstall with npm:\n\n```sh\n$ npm install alsa\n```\n\nor via git:\n\n```sh\n$ npm install git+https://github.com/xdissent/node-alsa.git\n```\n\n\nUsage\n-----\n\nThe `alsa` module exports 2 high-level classes for playback and recording, a simple wrapper class around PCM operations, and a subset of the low-level libasound2 functions.\n\n```js\nvar alsa = require('alsa'),\n\n  // The following variables represent the defaults for the Playback and Capture constructors.\n  device = 'default',                                 // ALSA default device\n  channels = 2,                                       // Stereo\n  rate = 44100,                                       // Sample rate\n  format = alsa.libasound.PCM_FORMAT_S16_LE,          // PCM format (signed 16 bit LE int)\n  access = alsa.libasound.PCM_ACCESS_RW_INTERLEAVED,  // Access mode\n  async =  false;                                     // Async-mode - YOU DO NOT WANT THIS!\n\n// The Capture class is a stream.Readable subclass.\nvar capture = new alsa.Capture(device, channels, rate, format, access, async);\ncapture.pipe(process.stdout);   // Treat it like any other readable stream.\n\n// The Playback class is a stream.Writable subclass.\nvar playback = new alsa.Playback(device, channels, rate, format, access, async);\nprocess.stdin.pipe(playback);   // Treat it like any other writable stream.\n\n// The Pcm class is a wrapper around common libasound2 functions.\nvar pcm = new alsa.Pcm(device, alsa.libasound.PCM_STREAM_CAPTURE);  // or PCM_STREAM_PLAYBACK\n\n// Open PCM device, set parameters, and prepare (chainable).\npcm.open().access(access).format(format).channels(channels).rate(rate).prepare();\n\n// PCM parameters are combo getters and setters.\nconsole.log('Channels: ' + pcm.channels());\n\n// Calculate some sizes and create a buffer.\nvar bytesPerFrame = pcm.bytesPerFrame(),\n  framesPerBuffer = 1024,\n  bufferSize = framesPerBuffer * bytesPerFrame,\n  buffer = new Buffer(bufferSize);\n\n// Read frames from PCM device into the buffer, then get the raw frames.\nvar readFrames = pcm.readi(buffer, framesPerBuffer),\n  frames = buffer.slice(0, readFrames * bytesPerFrame);\n  \n// Low level libasound2 api access works too (pcm.pcm is a libasound2 snd_pcm_t pointer).\nconsole.log(alsa.libasound.snd_pcm_name(pcm.pcm));\n```\n\n\nExamples\n--------\n\nDownsample audio captured from an ALSA device to a sample rate of 11025, in mono, encoded to 32 bit float PCM data and output to stdout:\n\n```coffeescript\nalsa = require 'alsa'\nstream = require 'stream'\n\nclass Downer extends stream.Transform\n  constructor: -> stream.Transform.call this\n\n  # Naively drop 3 out of 4 samples, combine the interleaved left and right into \n  # a single sample, then convert to 32 bit float PCM data.\n  _transform: (chunk, encoding, callback) ->\n  \n    # This is the naive part. Should be checking for partial samples.\n    floats = new Buffer chunk.length / 4\n    f = 0\n    for i in [0...chunk.length] by 16 # 4 bytes per frame downsampled by 4.\n      l16 = chunk.readInt16LE i       # Read left channel sample.\n      r16 = chunk.readInt16LE i + 2   # Read right channel sample.\n      # Sum samples and normalize as a float\n      floats.writeFloatLE (l16 + r16) / 65536, f\n      f += 4                          # Skip ahead 4 bytes in buffer (32 bit float).\n    @push floats  # Write transformed samples to stream...\n    callback()    # And we're done.\n\n# Create a Capture and a Downer and chain them to stdout.\ncapture = new alsa.Capture\ndowner = new Downer\ncapture.pipe(downer).pipe(process.stdout)\n```",
  "readmeFilename": "README.md",
  "_id": "alsa@0.0.1",
  "dist": {
    "shasum": "820cca7ff5dc9c8777c7df45a947998463b8ffba"
  },
  "_from": "alsa@0.0.1",
  "_resolved": "https://registry.npmjs.org/alsa/-/alsa-0.0.1.tgz"
}
